from parsimonious.exceptions import IncompleteParseError as IncompleteParseError, ParseError as ParseError
from parsimonious.nodes import Node as Node, RegexNode as RegexNode
from parsimonious.utils import StrAndRepr as StrAndRepr
from typing import Any

MARKER: Any

def expression(callable: Any, rule_name: Any, grammar: Any): ...

class Expression(StrAndRepr):
    name: Any = ...
    identity_tuple: Any = ...
    def __init__(self, name: str = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def parse(self, text: Any, pos: int = ...): ...
    def match(self, text: Any, pos: int = ...): ...
    def match_core(self, text: Any, pos: Any, cache: Any, error: Any): ...
    def as_rule(self): ...

class Literal(Expression):
    literal: Any = ...
    identity_tuple: Any = ...
    def __init__(self, literal: Any, name: str = ...) -> None: ...

class TokenMatcher(Literal): ...

class Regex(Expression):
    re: Any = ...
    identity_tuple: Any = ...
    def __init__(self, pattern: Any, name: str = ..., ignore_case: bool = ..., locale: bool = ..., multiline: bool = ..., dot_all: bool = ..., unicode: bool = ..., verbose: bool = ...) -> None: ...

class Compound(Expression):
    members: Any = ...
    def __init__(self, *members: Any, **kwargs: Any) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...

class Sequence(Compound): ...
class OneOf(Compound): ...
class Lookahead(Compound): ...
class Not(Compound): ...
class Optional(Compound): ...
class ZeroOrMore(Compound): ...

class OneOrMore(Compound):
    min: Any = ...
    def __init__(self, member: Any, name: str = ..., min: int = ...) -> None: ...
